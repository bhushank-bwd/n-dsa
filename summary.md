# Summary

## Array easy medium

| Question               | Solution                                                                                            |
| ---------------------- | --------------------------------------------------------------------------------------------------- |
| Single Number          | bitwise xor                                                                                         |
| Reverse String         | Half loop with swap (i,n-1-i)                                                                       |
| Remove Element         | x, i pointer and replace x<sup>th</sup> for input element                                           |
| Move Zero              | as last but fill remaining with zero                                                                |
| Missing Number         | Total sum - partial Sum                                                                             |
| Merge two sorted array | two actual last index and keep largest at last of first and check for if anyone array index exceeds |
| Max Profit             | keep min pointer and max profit                                                                     |
| max consecutive one    | keep two pointer currentCount and MaxCount and check also after loop                                |
| Remove Duplicates      | i and x and replace x<sup></sup> if i greater than x                                                |
|                        |                                                                                                     |

## Searching and Sorting

| Question       | Solution                                                                                                              |
| -------------- | --------------------------------------------------------------------------------------------------------------------- |
| Linear search  | search in array by single element at a time                                                                           |
| Binary search  | in sorted array, find mid and compare mid with target and adjust array by that, left should not cross right           |
| Merge sort     | use recursive approach(break at single element) get left, right array and return merge of left and right              |
| Bubble sort    | works in pair; last element sorted in every iteration; reduces one comparison in each iteration                       |
| Selection sort | in each iteration min element from start sorted; i = 0 and j = i+1                                                    |
| Insertion Sort | sort by 01, 012, 0123, so on; start from second element;previousIndex,currentElement,place to proper previous to next |
